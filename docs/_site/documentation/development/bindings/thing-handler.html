    <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1">
 


<link rel="shortcut icon" href="//www.eclipse.org/smarthome/img/favicon.png"></link>
<title>Eclipse SmartHome - A Flexible Framework for the Smart
	Home</title>
 
<!-- CSS -->
<link href="http://www.eclipse.org/smarthome/css/materialize.css" type="text/css" rel="stylesheet"
	media="screen,projection" />
<link href="http://www.eclipse.org/smarthome/css/highlight.github.css" type="text/css" rel="stylesheet"
    	media="screen,projection" />
<link href="../../../css/styles.css" rel="stylesheet" />

<!-- Font -->
<link href='http://fonts.googleapis.com/css?family=Lato:300,400,700'
	rel='stylesheet' type='text/css' />
    
</head>
<body class="documentation">
	<div id="header" class="navbar-fixed">
		<nav role="navigation">
			<div class="container">
				<div class="nav-wrapper">
					<a href="../../../index.html"><img id="logo" src="//www.eclipse.org/smarthome/img/eclipse_logo.png" /></a>
					<a href="#" data-activates="nav-mobile" class="button-collapse"><i
						class="mdi-navigation-menu"></i></a>
					<ul class="right hide-on-med-and-down">
						<li><a href="../../../getting-started.html">Getting Started</a></li>
						<li><a href="../../../documentation/index.html">Documentation</a></li>
						<li><a href="http://github.com/eclipse/smarthome">GitHub</a></li>
					</ul>
					<ul id="nav-mobile" class="side-nav">
                        <li><a href="../../../index.html">Home</a></li>
						<li><a href="../../../getting-started.html">Getting Started</a></li>
						<li><a href="../../../documentation/index.html">Documentation</a></li>
						<li><a href="http://github.com/eclipse/smarthome">GitHub</a></li>
					</ul>
				</div>
			</div>
		</nav>
	</div>
    
    <section id="documentation" class="text content-wrapper">
        <div class="container">
            <div class="side-nav-wrapper">
                




<ul class="nav">
    <li>
        <a href="../../../documentation/concepts/index.html">Concepts</a>
        <ul>
		    <li>
        		<a href="../../../documentation/concepts/index.html">Overview</a>
		    </li>
            <li>
                 <a href="../../../documentation/concepts/items.html">Items</a>
            </li>
            <li>
                 <a href="../../../documentation/concepts/things.html">Things</a>
            </li>
            <li>
                 <a href="../../../documentation/concepts/discovery.html">Inbox & Discovery</a>
            </li>
            <li>
                 <a href="../../../documentation/concepts/events.html">Events</a>
            </li>
		</ul>
	</li>
    <li>
        <a href="../../../documentation/features/index.html">Features</a>
        <ul>
            <li>
                 <a href="../../../documentation/features/index.html">Overview</a>
            </li>
            <li>
                 <a href="../../../documentation/features/rest.html">REST API</a>
            </li>
            <li>
                 <a href="../../../documentation/features/dsl.html">Textual Configuration</a>
            </li>
            <li>
                 <a href="../../../documentation/features/internationalization.html">Internationalization</a>
            </li>
			<!-- TBD: This could be a sub-menu "extensions", linking to the generated documentation from the /extensions folder
            <li>
                 <a href="../../../documentation/features/extensions/bindings.html">Bindings</a>
            </li>
            <li>
                 <a href="../../../documentation/features/extensions/uis.html">User Interfaces</a>
            </li>-->
    	</ul>
    </li>
	<li>
        <a href="../../../documentation/development/bindings/how-to.html">Development</a>
        <ul>
        	<!-- TODO: Once we have 3 menu levels, this could be moved to a "Bindings" sub-menu -->
        	<li>
                 <a href="../../../documentation/development/bindings/how-to.html">Binding Tutorial</a>
            </li>
            <li>
                 <a href="../../../documentation/development/bindings/thing-definition.html">Thing Definition</a>
            </li>
            <li>
                 <a href="../../../documentation/development/bindings/thing-handler.html">Thing Handler</a>
            </li>
            <li>
                 <a href="../../../documentation/development/bindings/xml-reference.html">XML Reference Guide</a>
            </li>
			<li>
                 <a href="../../../documentation/development/bindings/dependencies.html">Dependencies</a>
            </li>
			<li>
                 <a href="../../../documentation/development/bindings/testing.html">Testing</a>
            </li>
            <li>
                 <a href="../../../documentation/development/bindings/docs.html">Documentation</a>
            </li>
            <li>
                 <a href="../../../documentation/development/bindings/faq.html">FAQ</a>
            </li>
        </ul>    
    </li>
    <li>
        <a href="../../../documentation/community/guidelines.html">Community</a>
        <ul>
            <li>
                 <a href="../../../documentation/community/guidelines.html">Guidelines</a>
            </li>
            <li>
                 <a href="../../../documentation/community/ide.html">IDE</a>
            </li>
            <li>
                 <a href="../../../documentation/community/contributing.html">Contributing</a>
            </li>
        </ul>    
    </li>
</ul>
            </div>    
            <div class="content">  
	            
<h1 id="thing-handler-implementation">Thing Handler Implementation</h1>

<p>The <em>ThingHandler</em> has a lot of responsibilities like managing the communication between the framework and the external system, maintaining the lifecycle of a thing and it also must care about configuration changes. In this section the ThingHandler API is described in more detail and you get hints how to implement your binding.</p>

<h2 id="the-basethinghandler-class">The BaseThingHandler Class</h2>

<p>Eclipse SmartHome comes with a useful abstract base class named <code>BaseThingHandler</code>. It is recommended to use this class, because it covers a lot of common logic. Most of the explanations are based on the assumption, that the binding inherits from the BaseThingHandler in all concrete <code>ThingHandler</code> implementations. Nevertheless if there are reasons, why you can not use the base class, the binding can also directly implement the <code>ThingHandler</code> interface.</p>

<p>The communication between the framework and the ThingHandler is bidirectional. If the framework wants the binding to do something or just notfiy it about changes, it calls methods like <code>handleCommand</code>, <code>handleUpdate</code> or <code>thingUpdated</code>. If the ThingHandler wants to inform the framework about changes, it uses a callback. The <code>BaseThingHandler</code> provides convience methods like <code>updateState</code>, <code>updateStatus</code> and <code>updateThing</code>, that can be used to inform the framework about changes.</p>

<h2 id="lifecycle">Lifecycle</h2>

<p>The <code>ThingHandler</code> has a well defined lifecycle. The most two important lifecycle methods are: <code>initialize</code> and <code>dispose</code>. The <code>initialize</code> method is called, when the handler is started and <code>dispose</code> just before the handler is stopped. Therefore the methods can be used to allocate and deallocate resources. If the BaseThingHandlerFactory is used for creating and maintaining the handler instances, the detailed lifecycle looks as followed:</p>

<h3 id="startup">Startup</h3>

<ul>
  <li>Handler will be created: Constructor is called</li>
  <li>Handler will be initialized: <code>initialize</code> method is called</li>
  <li>Handler will be registered as OSGi service: It is visible to the framework and ready to work</li>
</ul>

<p>After the handler is registered as OSGi service, the <em>ThingHandler</em> should be ready to handle methods calls like <code>handleCommand</code> and <code>handleUpdate</code>, as well as <code>thingUpdated</code>.</p>

<h3 id="shutdown">Shutdown</h3>

<ul>
  <li>Handler will be unregistered as OSGi service: It is not visible anymore to the framework</li>
  <li>Handler will be disposed: <code>disposed</code> method is called</li>
</ul>

<p>After the handler is disposed, the framework will not call the handler anymore.</p>

<h2 id="handling-commands">Handling Commands</h2>

<p>For handling commands the <code>ThingHandler</code> interface defines the <code>handleCommand</code> method. This method is called, when a command is sent to an item, which is linked to a channel of the <em>Thing</em>. A Command represent the intention that an action should be executed on the external system, or that the state should be changed. Inside the <code>handleCommand</code> method binding specific logic can be executed.</p>

<p>The ThingHandler implementation must be prepared to handle different command types depending on the item types, that are defined by the channels. The method can also be called at the same time from different threads, so it must be thread-safe.</p>

<p>If an exception is thrown in the method, it will be caught by the framework and logged as an error. So it is better to handle communication errors within the binding and to update the thing status accordingly. Typically only the binding knows about the severity of an error and if it should be logged as info, warning or error message. If the communication to the device or service was successful it is good practice to set the thing status to <em>ONLINE</em> by calling <code>statusUpdated(ThingStatus.ONLINE)</code>.</p>

<p>The following code block shows a typical implementation of the <code>handleCommand</code> method:</p>

<pre><code class="language-java">@Override
public void handleCommand(ChannelUID channelUID, Command command) {
    try {
    	switch (channelUID.getId()) {
	    	case CHANNEL_TEMPERATURE:
	        	if(command instanceof OnOffType.class) {
	        		// binding specific logic goes here
	        		SwitchState deviceSwitchState = convert((OnOffType) command);
	        		updateDeviceState(deviceSwitchState);
	        	} 
	        	break;
	    	// ...
    	}
    	statusUpdated(ThingStatus.ONLINE);
	} catch(DeviceCommunicationException ex) {
		// catch exceptions and handle it in your binding
		logger.warn("Communication with device failed: " + ex.getMessage(), ex);
        statusUpdated(ThingStatus.OFFLINE);
    }
}
</code></pre>

<h2 id="updating-the-channel-state">Updating the Channel State</h2>

<p>State updates are sent from the binding to inform the framework, that the state of a channel has been updated. For this the binding developer can call a method from the <code>BaseThingHandler</code> class like this:</p>

<pre><code class="language-java">updateState("channelId", OnOffType.ON)
</code></pre>

<p>The call will be delegated to the framework, which changes the state of all bound items. It is binding specific when the channel should be updated. If the device or service supports an event mechanism the ThingHandler should make use of it and update the state every time, when the devices changes it state.</p>

<h3 id="polling-for-a-state">Polling for a State</h3>

<p>If no event mechanism is available, the binding can poll for the state. The <code>BaseThingHandlerFactory</code> has an accessible <code>ScheduledExecutorService</code>, which can be used to schedule a job. The following code block shows how to start a polling job in the initialize method of a <code>ThingHandler</code>, which runs with an interval of 30 seconds:</p>

<pre><code class="language-java">@Override
public void initialize() {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            // execute some binding specific polling code
        }
    };
    pollingJob = scheduler.scheduleAtFixedRate(runnable, 0, 30, TimeUnit.SECONDS);
}
</code></pre>

<p>Of course, the polling job must be cancelled in the dispose method:</p>

<pre><code class="language-java">@Override
public void dispose() {
    pollingJob.cancel(true);
}
</code></pre>

<p>Even if the state did not change since the last update, the binding should inform the framework, because it indicates that the value is still present.</p>

<h2 id="updating-the-thing-status">Updating the Thing Status</h2>

<p>The <em>ThingHandler</em> must also manage the thing status (see also: <a href="thing-status.md">Thing Status Concept</a>). If the device or service is not working correctly, the binding should change the status to <em>OFFLINE</em> and back to <em>ONLINE</em>, if it is working again. The status can be updated via an inherited method from the BaseThingHandler class by calling:</p>

<pre><code class="language-java">updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR);
</code></pre>

<p>The second argument of the method takes a <code>ThingStatusDetail</code> enumeration value, which further specifies the current status situation. A complete list of all thing statuses and thing status details is listed in the <a href="thing-status.md">Thing Status</a> chapter.</p>

<p>For debugging purposes the binding can also provide an additional status description. This description might contain technical information (e.g. an HTTP status code, or any other protocol specific information, which helps to identify the current problem):</p>

<pre><code class="language-java">updateStatus(ThingStatus.OFFLINE, ThingStatusDetail.OFFLINE.COMMUNICATION_ERROR, "HTTP 401");
</code></pre>

<p>After the thing is created, the framework calls the <code>initialize</code> method of the handler. At this time the state of the thing is <em>INTIALIZING</em> as long as the binding sets it to something else. Because of this the default implementation of the <code>initialize()</code> method in the <code>BaseThingHandler</code> just changes the status to <em>ONLINE</em>.</p>

<p><em>Note:</em> A binding should not set any other state than ONLINE, OFFLINE and REMOVED. All other states are managed by the framework.</p>

<h2 id="channel-links">Channel Links</h2>

<p>Some bindings might want to start specific functionality for a channel only if an item is linked to the channel. The <code>ThingHandler</code> has two callback methods <code>channelLinked(ChannelUID channelUID)</code> and <code>channelUnlinked(ChannelUID channelUID)</code>, which are called for every link that is added or removed to/from a channel. So please be aware of the fact, that both methods can be called multiple times.</p>

<p>The <code>channelLinked</code> method is called, even if the link existed before the handler was initialized. It will be called only after the <code>initialized</code> method has been executed successfully and the handler was registered as OSGi service. To check if a channel is linked at the time, when <code>channelLinked</code> or <code>channelUnlinked</code> is called, you can use the <code>isLinked(String channelID)</code> method from the <code>BaseThingHandler</code> class.</p>

<h2 id="handling-thing-updates">Handling Thing Updates</h2>

<p>If the structure or the configuration of a thing was changed during runtime (after the thing was created), the binding is informed about this change in the ThingHandler within the <code>thingUpdated</code> method. The <code>BaseThingHandler</code> has a default implementation for this method:</p>

<pre><code class="language-java">@Override
public void thingUpdated(Thing thing) {
    dispose();
    this.thing = thing;
    initialize();
}
</code></pre>

<p>If your binding contains resource-intensive logic in your initialize method, you should think of implementing the method by yourself and figuring out, what is the best way to handle the change.</p>

<p>For configuration updates, which are triggered from the binding, the framework does not call the <code>thingUpdated</code> method to avoid infinite loops.</p>

<h2 id="updating-the-thing-from-a-binding">Updating the Thing from a Binding</h2>

<p>It can happen that the binding wants to update the configuration or even the whole structure of a thing. If the <code>BaseThingHandler</code> class is used, it provides some helper methods for modifying the thing.</p>

<h3 id="updating-the-configuration">Updating the Configuration</h3>

<p>Usually the configuration is maintained by the user, and the binding is informed about the updated configuration. But if the configuration can also be changed in the external system, the binding should reflect this change, and notify the framework about it.</p>

<p>If the configuration should be updated, then the binding developer can retrieve a copy of the current configuration by calling <code>editConfiguration()</code>. The updated configuration can be stored as a whole by calling <code>updateConfiguration(Configuration)</code>.</p>

<p>Suppose that an external system causes an update of the configuration, which is read in as a <code>DeviceConfig</code> instance. The following code shows how to update configuration:</p>

<pre><code class="language-java">protected void deviceConfigurationChanged(DeviceConfig deviceConfig) {
    Configuration configuration = editConfiguration();
    configuration.put("parameter1", deviceConfig.getValue1());
    configuration.put("parameter2", deviceConfig.getValue2());
    updateConfiguration(configuration);
}
</code></pre>

<p>The <code>BaseThingHandler</code> will propagate the update to the framework, which then notifies all registered listeners about the updated thing. But the thing update is <strong>not</strong> propagated back to the handler through a <code>thingUpdated(Thing)</code> call.</p>

<h3 id="updating-thing-properties">Updating Thing Properties</h3>

<p>Thing properties can be updated in the same way as the configuration. The following example shows how to modify two properties of a thing:</p>

<pre><code class="language-java">protected void devicePropertiesChanged(DeviceInfo deviceInfo) {
	Map&lt;String, String&gt; properties = editProperties();
    properties.put(Thing.PROPERTY_SERIAL_NUMBER, deviceInfo.getSerialNumber());
    properties.put(Thing.PROPERTY_FIRMWARE_VERSION, deviceInfo.getFirmwareVersion());
    updateProperties(properties);
}
</code></pre>

<p>If only one property must be changed, there is also a convenient method <code>updateProperty(String name, String value)</code>. Both methods will only inform the framework, that the thing was modified, if at least one property was added, removed or updated.</p>

<h3 id="updating-the-thing-structure">Updating the Thing Structure</h3>

<p>The binding also has the possibility to change the thing structure by adding, or removing channels. The following code shows how to use the ThingBuilder to add one channel to the thing:</p>

<pre><code class="language-java">protected void thingStructureChanged() {
    ThingBuilder thingBuilder = editThing();
    Channel channel = ChannelBuilder.create(new ChannelUID("bindingId:type:thingId:1"), "String").build();
    thingBuilder.withChannel(channel);
    updateThing(thingBuilder.build());
}
</code></pre>

<p>As the builder does not support removing a channel, the developer has top copy the existing channels into a modifiable list and remove the channel in this list. The list can be passed as argument to the <code>withChannels()</code> method of the <code>ThingBuilder</code>, which overrides the complete list of channels.</p>

<h2 id="handling-thing-removal">Handling Thing Removal</h2>

<p>If a thing should be removed, the framework informs the binding about the removal request by calling <code>handleRemoval</code> at the thing handler. The thing will not be removed from the runtime, before the binding confirms the deletion by setting the thing status to <code>REMOVED</code>. If no special removal handling is required by the binding, you do not have to care about removal, because the default implementation of this method in the <code>BaseThingHandler</code> class just calls <code>updateStatus(ThingStatus.REMOVED)</code>.</p>

<p>But for some radio-based devices it is needed to communicate with the device in order to unpair it safely. After the device was successfully unpaired, the binding can inform the framework that the thing was removed by setting the thing status to <code>REMOVED</code>.</p>

<p>After the removal was requested the status of the thing is <code>REMOVING</code> and can not be changed back to <code>ONLINE</code> or <code>OFFLINE</code> by the binding. The binding can only initiate the status transition to <code>REMOVED</code>.</p>

            </div>
        </div>
    </section>
    
	    


	     
    <footer class="page-footer">
		<div class="container">
			<div class="row">
				<div class="col l6 s12">
					<p class="white-text">Eclipse SmartHome is an <a href="http://iot.eclipse.org">Eclipse IoT</a>
						project</p>
					<p>
						<a href="http://iot.eclipse.org"><img src="//www.eclipse.org/smarthome/img/iot-logo.png"></a>
					</p>
				</div>
				<div class="col l6 s12" data-twttr-id="twttr-sandbox-0">
					<p class="white-text">Connect with Eclipse SmartHome</p>
					<iframe
						src="https://ghbtns.com/github-btn.html?user=eclipse&repo=smarthome&type=star&count=true&size=large"
						frameborder="0" scrolling="0" width="160px" height="30px"></iframe>
					<br /> <a class="twitter-follow-button" data-size="large"
						href="https://twitter.com/smarthome"> Follow @smarthome</a><br />
				</div>
			</div>
		</div>
		<div class="footer-copyright">
			<div class="container center">
				<a href="https://www.eclipse.org/legal/copyright.php">Copyright
					Agent</a> · <a href="https://www.eclipse.org/legal/privacy.php">Privacy</a>
				· <a href="https://www.eclipse.org/legal/termsofuse.php">Terms</a> ·
				<a href="https://www.eclipse.org/legal/">Legal</a>

			</div>
		</div>
	</footer>
    
	<script src="//www.eclipse.org/smarthome/js/jquery.min.js"></script>
	<script src="//www.eclipse.org/smarthome/js/jquery.scrollme.min.js"></script>
    <script src="//www.eclipse.org/smarthome/js/jquery.sticky.js"></script>
	<script src="//www.eclipse.org/smarthome/js/materialize.js"></script>
    <script src="//www.eclipse.org/smarthome/js/highlight.pack.js"></script>
	<script src="../../../js/init.js"></script>
	<script>
        window.twttr = (function(d, s, id) {
            var js, fjs = d.getElementsByTagName(s)[0], t = window.twttr || {};
            if (d.getElementById(id))
                return t;
            js = d.createElement(s);
            js.id = id;
            js.src = "https://platform.twitter.com/widgets.js";
            fjs.parentNode.insertBefore(js, fjs);

            t._e = [];
            t.ready = function(f) {
                t._e.push(f);
            };

            return t;
        }(document, "script", "twitter-wjs"));
    </script>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-55850963-1', 'auto');
  ga('send', 'pageview');

</script>
</body>
</html>